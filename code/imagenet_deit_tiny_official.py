# -*- coding: utf-8 -*-
"""VisionTransformers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OtvGSH_lSOHjmnu_Dsepz2xj_FGnnA6n
"""

from timm.models.vision_transformer import VisionTransformer
from timm.data.constants import IMAGENET_DEFAULT_MEAN, IMAGENET_DEFAULT_STD
from timm.data import create_transform
import torch
from torch import nn, einsum
from torch.utils.data import DataLoader, SequentialSampler, RandomSampler
from torchvision.datasets import CIFAR10, CIFAR100, ImageNet, ImageFolder
from torchvision import transforms
from torch.optim import Adam, lr_scheduler
from tqdm import tqdm

from functools import partial

if torch.cuda.is_available():
    device = torch.device('cuda')
    print(f'{torch.cuda.device_count()} GPU(s) available.')
    print('Device name:', torch.cuda.get_device_name(0))
else:
    print('No GPU available, using the CPU instead.')
    device = torch.device("cpu")


def train_model(model, train_data, eval_data, path, epochs, loss_fn, optimizer, scheduler, **args):
    model.to(device)
    model.train()
    best_eval_loss = 1e8
    
    for epoch in tqdm(range(epochs), desc="Epochs", leave=False):
        total_loss = 0.0
        print(f"\nEpoch: {epoch}")

        for i, data in enumerate(tqdm(train_data, desc="Training", leave=False)):
            
            inputs, labels = tuple(t.to(device) for t in data)
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = loss_fn(outputs, labels)
            loss.backward()
            optimizer.step()

            total_loss += loss.item()*inputs.size(0)
        
        print(f"Train loss = {total_loss/len(train_data.sampler)}")

        model.eval()
        eval_loss = 0.0

        with torch.no_grad():
            for i, data in enumerate(tqdm(eval_data, desc="Evaluating", leave=False)):
                inputs, labels = tuple(t.to(device) for t in data)
                outputs = model(inputs)
                loss = loss_fn(outputs, labels)
                eval_loss += loss.item()*inputs.size(0)
        
        eval_loss = eval_loss/len(eval_data.sampler)
        scheduler.step(metrics=eval_loss)

        if eval_loss < best_eval_loss:
            torch.save(model.state_dict(), path)
            best_eval_loss = eval_loss

        print(f"Validation loss = {eval_loss}")

def print_metrics(model, test_data, metric_funcs, loss_fn=None, width_list=None, width_switch=False):
    model.eval()
    model.to(device)

    if loss_fn is None:
        loss_fn = nn.CrossEntropyLoss()

    if width_list:
        print(f"Width | {'Loss':^20}", end = "")
        for metric, args in metric_funcs:
            print(f" | {metric.__name__:^20}", end = "")
        print()
        for k, width in enumerate(width_list):
            print(f"{width:^5}", end = "")
            model.apply(lambda m: setattr(m, 'width_mult', width))
            preds = []
            truths = []
            
            total_loss = 0
            with torch.no_grad():
                for i, data in enumerate(test_data):
                    inputs, labels = tuple(t.to(device) for t in data)
                    if width_switch:
                        outputs = model(inputs, width_n=k)
                    else:
                        outputs = model(inputs)
                    loss = loss_fn(outputs, labels)
                    total_loss += loss.item()*inputs.size(0)
                    preds = preds + list(
                        torch.argmax(
                            nn.functional.softmax(outputs.cpu(), dim=1), 
                            dim=1
                            )
                        )
                    truths = truths + list(labels.cpu())
            test_loss = total_loss/len(test_data.sampler)
            print(f" | {test_loss:^20.4f}", end = "")
            for metric, args in metric_funcs:
                perf = metric(truths, preds, **args)
                print(f" | {perf:^20.4f}", end = "")
            print()
    else:
        preds = []
        truths = []
        total_loss = 0
        with torch.no_grad():
            for i, data in enumerate(test_data):
                inputs, labels = tuple(t.to(device) for t in data)
                outputs = model(inputs)
                loss = loss_fn(outputs, labels)
                total_loss += loss.item()*inputs.size(0)
                preds = preds + list(
                    torch.argmax(
                        nn.functional.softmax(outputs.cpu(), dim=1), 
                        dim=1
                        )
                    )
                truths = truths + list(labels.cpu())
        test_loss = total_loss/len(test_data.sampler)
        print(f"Loss: {test_loss}")
        for metric, args  in metric_funcs:
            perf = metric(truths, preds, **args)
            print(f"{metric.__name__}: {perf:^.4f}")

path_train = "../data/ImageNet200FullSize/train"
path_val = "../data/ImageNet200FullSize/val"

model = VisionTransformer(
        patch_size=16, embed_dim=192, depth=12, num_heads=3, mlp_ratio=4, qkv_bias=True,
        norm_layer=partial(nn.LayerNorm, eps=1e-6))

train_transforms = create_transform(
            input_size=224,
            is_training=True,
            color_jitter=0.4,
            auto_augment='rand-m9-mstd0.5-inc1',
            interpolation='bicubic',
            re_prob=0.25,
            re_mode='pixel',
            re_count=1
        )
val_transforms = transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean=IMAGENET_DEFAULT_MEAN, std=IMAGENET_DEFAULT_STD)
    ])

train_dataset = ImageFolder(path_train, transform=train_transforms)
train_sampler = RandomSampler(train_dataset)
train_loader = DataLoader(train_dataset, sampler=train_sampler, batch_size=64)
val_dataset = ImageFolder(path_val, transform=val_transforms)
val_sampler = SequentialSampler(val_dataset)
test_loader = DataLoader(val_dataset, sampler=val_sampler, batch_size=64)

optimizer = Adam(model.parameters(), lr=1e-4)
scheduler = lr_scheduler.ReduceLROnPlateau(optimizer, patience=7, factor=0.3)

train_model(model, train_loader, test_loader, "../models/official_deit_tiny_aug.pt", epochs=100, loss_fn=nn.CrossEntropyLoss(), optimizer=optimizer, scheduler=scheduler)

model.load_state_dict(torch.load("../models/official_deit_tiny_aug.pt"))

from sklearn.metrics import accuracy_score
print_metrics(model, test_loader, [
     (accuracy_score, {}), 
      ])

